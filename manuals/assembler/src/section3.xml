<?xml version="1.0"?>
<chapter xmlns="http://docbook.org/ns/docbook">
  <title>Interactive Debugger</title>
  <section>
    <title>Introduction</title>
    <para>
The Interactive Debugger is a powerful tool for system diagnostics
or testing 6809 machine language programs. It is also useful when you
need to directly access the computer's memory for any of a number of
reasons: testing I/O interfaces, verifying data, etc. The calculator
mode can simplify computation of addresses, radix conversion, and other
mathematical problems often encountered by machine language programmers.
</para>
    <section>
      <title>Installation</title>
      <para>
The Interactive Debugger program is supplied on a file called
<quote>DEBUG</quote> which should be located in the system's execution directory
(usually <quote>/D0/CMDS</quote>) .
</para>
    </section>
    <section>
      <title>Calling the Interactive Debugger</title>
      <para>
After the installation procedure, given above, has been performed,
the Interactive Debugger may be executed from OS-9 by typing:
</para>
      <screen>
OS9: debug
</screen>
    </section>
    <section>
      <title>Basic Concepts</title>
      <para>
The debugger operates in response to single line commands typed in
from the keyboard. You can tell when you are communicating with_the
debugger because it always displays a <quote>DB:</quote> prompt when it expects a
command line.
</para>
      <para>
Each line is terminated by a <keycap>RETURN</keycap>. If you make a mistake while
typing, you can use the backspace key, or you can delete the entire line
using the <keycombo action="simul"><keycap>CONTROL</keycap><keycap>X</keycap></keycombo> key.
</para>
      <para>
Each command line starts with a single character command which may
be followed by text or one or two arithmetic expressions depending on the
specific command. Uppercase and lowercase characters can be used
interchangeably. Here's an example of the <quote>space</quote> command which displays
the result of an expression in hexadecimal and decimal notation:

<screen>
DB:  A+2 <keycap>RETURN</keycap>
    $000C  #00012
DB:
</screen>

Numbers entered into or displayed by the debugger are in hexadecimal
notation unless special commands are used, such as the decimal conversion
command shown above.
</para>
      <important>
        <title>Important note</title>
        <para>
The exact format of displays generated by some of the
commands may be different than the examples in this book. This is due to
customization for the screen size of specific computers.
</para>
      </important>
    </section>
  </section>
  <section>
    <title>Expressions</title>
    <para>
A powerful feature of the Interactive Debugger is its integral
expression interpreter, which permits you to type in simple or complex
expressions wherever an input value is called for in a command.
Expressions used by the Interactive Debugger are similar to those used
with high-level languages such as BASIC, except there are some extra
operators and operands that are unique to the debugger.
</para>
    <para>
Numbers used in expressions are 16 bit unsigned integers, which is
the 6809's <quote>native</quote> arithmetic representation. The allowable range of
numbers is therefore zero to 65535. Two's complement addition and
subtraction is performed correctly, but will print out as large positive
numbers in decimal form. Some commands require byte values and an error
message will be given if the result of the expression is too large to be
stored in a byte (when the result &gt; 255 ). Also, some operands are only
a byte long (such as individual memory locations and some registers).
These are automatically converted to 16-bit <quote>words</quote> without sign
extension. Spaces may be used between operators and operands as desired
to improve readability but do not affect evaluation.
</para>
    <section>
      <title>Constants</title>
      <para>
Constants can be in base 2 (<quote>binary</quote>), base 10 (<quote>decimal</quote>), or base
16 (hexadecimal or <quote>hex</quote>). Binary and decimal constants require a prefix
character: % (binary) or # (decimal). All other numbers are assumed to be
hex. Hex numbers may also have an optional $ prefix. Here are some
examples:
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="3">
          <colspec colwidth="1.3in"/>
          <colspec colwidth="1.3in"/>
          <colspec colwidth="2.0in"/>
          <thead rowsep="1">
            <row>
              <entry>Decimal</entry>
              <entry>Hexadecimal</entry>
              <entry>Binary</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>#100</entry>
              <entry>64</entry>
              <entry>%1100110</entry>
            </row>
            <row>
              <entry>#255</entry>
              <entry>FF</entry>
              <entry>%11111111</entry>
            </row>
            <row>
              <entry>#6000</entry>
              <entry>1770</entry>
              <entry>%1011101110000</entry>
            </row>
            <row>
              <entry>#65535</entry>
              <entry>FFFF</entry>
              <entry>%1111111111111111</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
Character constants may also be used. A single quote ' for one
character constants and a double quote " for two character constants.
These produce the numerical value of the ASCII codes for the character(s)
which follow. For example:
</para>
      <simplelist type="vert">
        <member>'A = $0041</member>
        <member>'0 = $0030</member>
        <member>"AB = $4142</member>
        <member>"99 = $3939</member>
      </simplelist>
    </section>
    <section>
      <title>Special Names</title>
      <para>
There are other legal operands in expressions; <quote>Dot</quote>, <quote>Dot-Dot</quote>, and register names.
</para>
      <para>
<quote>Dot</quote> is simply the debugger's current working address in memory.
It can be examined, changed, updated, used in expressions, or recalled.
It has the main effect of eliminating a tremendous amount of memory
address typing. The following command prints the current working
address:
<screen>
DB: . <keycap>RETURN</keycap>
    2204 82
</screen>

<quote>Dot-Dot</quote> is the value of <quote>Dot</quote> <emphasis>before</emphasis> the last time it was changed.
It is convenient to use if you change dot to an incorrect value, or as a
second address <quote>memory</quote>. For example, the following command prints the
value of <quote>Dot-Dot</quote>:
<screen>
DB: . 400 <keycap>RETURN</keycap>               <lineannotation>(set Dot to 400)</lineannotation>
DB: . 800 <keycap>RETURN</keycap>               <lineannotation>(change Dot to 800)</lineannotation>
DB: .. <keycap>RETURN</keycap>                  <lineannotation>(display Dot-Dot)</lineannotation>
    0400 12
DB: . .. <keycap>RETURN</keycap>                <lineannotation>(change Dot to Dot-Dot)</lineannotation>
</screen>

</para>
    </section>
    <section>
      <title>Register Names</title>
      <para>

MPU Registers may be specified by a colon character <quote>:</quote> followed by
the mnemonic name of the register; for example:
</para>
      <informaltable frame="none" colsep="0" rowsep="0">
        <tgroup cols="2">
          <colspec colwidth="1.0in"/>
          <colspec colwidth="5.0in"/>
          <tbody>
            <row>
              <entry>:A</entry>
              <entry>Accumulator A</entry>
            </row>
            <row>
              <entry>:B</entry>
              <entry>Accumulator B</entry>
            </row>
            <row>
              <entry>:D</entry>
              <entry>Accumulator D</entry>
            </row>
            <row>
              <entry>:X</entry>
              <entry>X Register</entry>
            </row>
            <row>
              <entry>:Y</entry>
              <entry>Y Register </entry>
            </row>
            <row>
              <entry>:U</entry>
              <entry>U Register</entry>
            </row>
            <row>
              <entry>:DP</entry>
              <entry>Direct Page Register</entry>
            </row>
            <row>
              <entry>:SP</entry>
              <entry>Stack Pointer</entry>
            </row>
            <row>
              <entry>:PC</entry>
              <entry>program counter register </entry>
            </row>
            <row>
              <entry>:CC</entry>
              <entry>Condition Codes Register</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>
The values returned are of the program under test's registers, which are
<quote>stacked</quote> when the debugger is active. Those registers which are a
single byte long are promoted to a word when used in expressions.
</para>
      <para>
NOTE: When a program is interrupted by a breakpoint, the SP register
will be pointing at the bottom of the MPU register stack.
</para>
    </section>
    <section>
      <title>Operators</title>
      <para>
Operators specify arithmetic or logical operations to be performed
within an expression. The operators having a higher precedence
(priority) are executed before those having lower precedence. For
example, all multiplications are performed before additions. Operators
in a single expression having equal precedence are evaluated left to
right. Parentheses may be used to override precedence as desired. Here
are the operators, in precedence order:
</para>
      <informaltable frame="none" rowsep="0" colsep="0">
        <tgroup cols="3">
          <colspec colwidth="2.0in"/>
          <colspec colwidth="2.0in"/>
          <colspec colwidth="2.0in"/>
          <tbody>
            <row>
              <entry>+ addition</entry>
              <entry>- subtraction</entry>
              <entry>&lt;- Lowest</entry>
            </row>
            <row>
              <entry>* multiplication</entry>
              <entry>/ division</entry>
              <entry/>
            </row>
            <row>
              <entry>&amp; logical AND</entry>
              <entry>! logical OR</entry>
              <entry/>
            </row>
            <row>
              <entry>- negative</entry>
              <entry/>
              <entry>&lt;- Highest</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section>
      <title>Indirect Addressing</title>
      <para>
The Indirect Addressing function returns the data at the memory
address using a value (expression, constant, special name, etc.) as the
memory address. The Interactive debugger has two indirect addressing
modes:
</para>
      <variablelist spacing="compact">
        <varlistentry>
          <term>&lt; <replaceable>expr</replaceable> &gt;</term>
          <listitem>
            <para>
returns the value of a memory <emphasis>byte</emphasis> using the value of <quote><replaceable>expr</replaceable></quote> as an address
          </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>[ <replaceable>expr</replaceable> ]</term>
          <listitem>
            <para>returns the value of a 16-bit <emphasis>word</emphasis> using the value of <quote><replaceable>expr</replaceable></quote> as an address</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
Here are some examples:
</para>
      <variablelist spacing="compact">
        <varlistentry>
          <term>&lt;200&gt;</term>
          <listitem>
            <para>returns the value of the byte at address 200</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>[:X]</term>
          <listitem>
            <para>returns the value of the word pointed to by the X register</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>[.+10]</term>
          <listitem>
            <para>returns the value of the word at address dot plus 10.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Forming Expressions</title>
      <para>
An expression can be composed of any combination of constants,
register names, special names, and operators. Here are some examples:
</para>
      <simplelist type="horiz" columns="3">
        <member>#1024+#128</member>
        <member>:X-:B-2</member>
        <member>.+20</member>
        <member>:Y*(:X+:A)</member>
        <member>:U &amp; FFFE</member>
        <member>#125</member>
      </simplelist>
    </section>
  </section>
  <section>
    <title>Debug Commands</title>
    <section>
      <title>Calculator Command</title>
      <para>
To use the calculator command, enter a line starting with one or
more spaces followed by any legal expression, then <quote>return</quote>. The
expression will be evaluated and the result displayed on the following.
line in both hexadecimal and decimal representations.
</para>
      <para>
Here are some examples:

<screen>
DB:<keycap>SPACE</keycap> 5000+200 <keycap>RETURN</keycap>
    $5200 #20992

DB:<keycap>SPACE</keycap> 8800/2 <keycap>RETURN</keycap>
    $4400 #17408

DB:<keycap>SPACE</keycap> #100+#12 <keycap>RETURN</keycap>
    $0070 #00112
</screen>

These commands are also handy for converting values from one
representation to another:
<screen>
DB:<keycap>SPACE</keycap> %11110000 <keycap>RETURN</keycap>
    $00F0 #00240

DB:<keycap>SPACE</keycap> 'A <keycap>RETURN</keycap>
    $0041 #00065

DB:<keycap>SPACE</keycap> #100 <keycap>RETURN</keycap>
    $00C4 #00100
</screen>
You can also use indirect addressing to look at memory without changing Dot:
<screen>
DB:<keycap>SPACE</keycap> &lt;.&gt; <keycap>RETURN</keycap>
    $004F #00079
</screen>
Another trick is simulating 6809 indexed or indexed indirect
instructions. For example:
<screen>
DB:<keycap>SPACE</keycap> [:D+:Y] <keycap>RETURN</keycap>
</screen>
is the same as the assembly language syntax [D,Y].
</para>
    </section>
    <section>
      <title><quote>Dot</quote> and Memory Examine/Change Commands</title>
      <section>
        <title>Display Dot Command</title>
        <para>

Typing <quote>.</quote> causes the current value of Dot and the contents of that
memory address to be displayed, for example:

<screen>
DB:. <keycap>RETURN</keycap>  display Dot
2201 B0
</screen>

The first number, 2201, is the present value of Dot, and B0 is the
contents of memory location 2201.

</para>
      </section>
      <section>
        <title>Change Dot Command</title>
        <para>

To change the value of Dot, type a period followed by an expression which
is to be the new value, for example:

<screen>
DB:. 500 <keycap>RETURN</keycap> set Dot to 500
    500 12
</screen>

One additional feature: whenever Dot is changed; its last value is saved,
and can be restored by typing two periods:

<screen>
DB:. <keycap>RETURN</keycap> display Dot
    1000 23 .
DB:. 2000 <keycap>RETURN</keycap> set Dot to 2000
    2000 9C
DB:.. <keycap>RETURN</keycap> restore old value of Dot
    1000 23
</screen>

</para>
      </section>
      <section>
        <title>Advance Dot Command</title>
        <para>

Typing a line with just <keycap>RETURN</keycap>, advances Dot to the next memory address
and prints its new value and contents. The example below shows how to
<quote>step through</quote> sequential memory locations.
</para>
        <screen>
DB:<keycap>RETURN</keycap>
    2202 05
DB:<keycap>RETURN</keycap>
    2203 C2
DB:<keycap>RETURN</keycap>
    2204 82
</screen>
      </section>
      <section>
        <title>Backstep Dot Command</title>
        <para>

The <quote>-</quote> command backs up Dot one address and prints its value and
contents:
</para>
        <screen>
DB:. <keycap>RETURN</keycap> display Dot
    2204 82
DB:- <keycap>RETURN</keycap> backstep one address
    2203 C2
DB:- <keycap>RETURN</keycap> backstep one address
    2202 05
</screen>
      </section>
      <section>
        <title>Change Memory Command</title>
        <para>

To change the contents of the memory-location pointed to by Dot, type an
equal sign followed by an expression. The expression is evaluated, and
the result stored at the current Dot address. Dot is then advanced to
the location whose address and contents are displayed.
</para>
        <para>
The memory location is checked after the new value is stored to make sure
it actually changed to the correct value. If it didn't, an error message
is displayed. Error messages are displayed when an attempt is made to
alter non-RAM memory. In particular, many 6800-family interface devices
(such as PIAs, ACIAs, etc.) have registers that will not read the same as
when written to.
</para>
        <screen>
DB:. <keycap>RETURN</keycap> display Dot
    2203 C2
DB:=FF <keycap>RETURN</keycap> change memory to FF
    2204 01
DB:- <keycap>RETURN</keycap> backspace and display
    2203 FF
</screen>
        <warning>
          <para>
This command permits any memory location to be changed. You can
accidentally crash the debugger, the program under test, or OS-9 if you
incorrectly change their memory areas.
</para>
        </warning>
      </section>
    </section>
    <section>
      <title>Register Examine/Change Commands</title>
      <para>
Several forms of the <quote>:</quote> register command can be used to examine one
or all registers, or to change a specific register's contents.
</para>
      <para>
The <quote>registers</quote> affected by these commands, are actually stored
copies in memory (<quote>images</quote>) of the register values of_the.program under
test. They are stored on the stack when the program is stopped by a
breakpoint or other interrupt. The value shown for the stack pointer
register is the address ,of the stack where the register values are
stored. Before the program under test is first executed, the register
images must be made valid using the <quote>E</quote> command.
</para>
      <para>
When a running program is interrupted by a
<keycombo action="simul"><keycap>CONTROL</keycap><keycap>C</keycap></keycombo> key or by a
breakpoint, the registers are once again stacked for inspection and/or
change. Note that if you manually alter the value of the SP register
during program testing, the address of the stack and the register values
will also change. If you change the condition codes (CC) register,
the E bit must be kept set to ensure all registers are reloaded properly when
program execution is resumed.
</para>
      <section>
        <title>Display All Registers Command.</title>
        <para>
To display all registers, type <quote>:</quote> followed by <keycap>RETURN</keycap>. For example:

<screen>
DB:: <keycap>RETURN</keycap>
     SP  CC  A  B DP   X    Y    U   PC
    C499 C4 20 1C 01 DD3E 239A 0000 240C
</screen>

</para>
      </section>
      <section>
        <title>Display Specific Register Command</title>
        <para>
To display the contents of a specific register, enter a colon ":
followed by the register name. The Debugger will respond by displaying
the current register contents in hex. Examples:
</para>
        <screen>
DB::PC <keycap>RETURN</keycap> display PC register
    C499
DB::B <keycap>RETURN</keycap> display B register
    007E
DB::SP <keycap>RETURN</keycap> display SP register
    42FD
</screen>
      </section>
      <section>
        <title>Change Register Command</title>
        <para>
To assign a new value to a register, type the register name followed
by an expression. The expression is evaluated and stored in the register
specified. When 8-bit registers are named, the expression given must
have a value that fits in a single byte, or an error message is displayed
and the register is not changed.
</para>
        <para>
Here are some examples:
</para>
        <screen>
DB::X #4096 <keycap>RETURN</keycap> Set x register to 4096

DB::DP 0        Set DP register to 0

DB::D 24CF+:Y  Set D register to 24CF plus contents of Y register
</screen>
      </section>
    </section>
    <section>
      <title>Breakpoint Commands</title>
      <para>
Breakpoints allow you to specify address(es) where execution of the
program under test is to be suspended and the debugger re-entered. When
a breakpoint is encountered, the values of the MPU registers and the
<quote>DB:</quote> prompt will be displayed. After a breakpoint is reached,-registers
can be examined or changed, memory can be altered, or any other debugger
command can be used. Program execution can be resumed from the
breakpoint location using the <quote>G</quote> command. Breakpoints may be inserted
at up to 12 different addresses.
</para>
      <para>
The debugger uses the 6809 SWI instruction for breakpoints. They
are inserted in memory in place of the machine language instruction
opcodes which are saved for restoration later. The SWI instructions are
automatically inserted and removed by the debugger at the right time so
you will not see them in memory.
</para>
      <para>
When a SWI is executed it interrupts.the program and saves the
register contents .on the stack so they can be examined or changed using
the <quote>:</quote> command. Because SWIs operate by temporarily replacing an
instruction opcode, there are three restrictions on their use:
</para>
      <orderedlist>
        <listitem>
          <para>
Breakpoints cannot be used with programs in ROM.
</para>
        </listitem>
        <listitem>
          <para>
Breakpoints must be located in the first (opcode) byte of the instruction.
</para>
        </listitem>
        <listitem>
          <para>
User programs cannot utilize the SWI instruction for other purposes (but SWI2 and SWI3 can be used).
</para>
        </listitem>
      </orderedlist>
      <para>
When the breakpoint is encountered during execution of the program
under test, the debugger is reentered and the program's register contents
is displayed using the same format as the <quote>display register</quote> command.
</para>
      <section>
        <title><quote>B</quote> Set or Display Breakpoints Command</title>
        <para>
The B command-will insert a breakpoint if followed by an expression,
or will display all present breakpoint addresses if used alone.
</para>
        <screen>
DB:B 1C00 <keycap>RETURN</keycap> set breakpoint at 1C00
DB:B 4FD3 <keycap>RETURN</keycap> set breakpoint at 4FD3
DB:. <keycap>RETURN</keycap> display Dot
    1277 39
DB:B . <keycap>RETURN</keycap> set breakpoint at Dot (1277)
DB:B <keycap>RETURN</keycap> display current breakpoints
    1C00 4FD3 1277
</screen>
      </section>
      <section>
        <title><quote>K</quote> Remove Breakpoint Command</title>
        <para>

The K command removes (<quote>kills</quote>) a breakpoint at a specific address if
followed by an expression or ALL (caution!) breakpoints if used alone;
</para>
        <screen>
DB:B <keycap>RETURN</keycap>                    <lineannotation>display current breakpoints</lineannotation>
    1C00 4FD3 1277
DB:K 4FD3 <keycap>RETURN</keycap>               <lineannotation>kill breakpoint at 4Fd3</lineannotation>
DB:B <keycap>RETURN</keycap>                    <lineannotation>display current breakpoints</lineannotation>
    1C00 1277
DB:K <keycap>RETURN</keycap>                    <lineannotation>kill all remaining breakpoints</lineannotation>
DB:B <keycap>RETURN</keycap>                    <lineannotation>display current breakpoints</lineannotation>
                               <lineannotation>none left so display is blank</lineannotation>
DB:
</screen>
      </section>
    </section>
    <section>
      <title>Program Setup And Run Commands</title>
      <section>
        <title>Prepare To Execute Command</title>
        <para>
The Execute command consists of a <quote>E</quote> by a Shell-style command
line. It prepares for testing of a specific program module and must be
used before the program is run.
</para>
        <para>
The <quote>E</quote> command performs the rough equivalent of what the OS-9 <command>Shell</command>
does to start a program except for I/O redirection (&lt;, &gt;, &gt;&gt;), memory
size override (<quote>#</quote>), and multitasking (<quote>&amp;</quote>) functions.
It sets up a stack, parameters, registers, and data memory area in preparation for
execution of the program to be tested.
The <quote>G</quote> command is actually used to start running the program.
</para>
        <para>
Note that this command will allocate program and data area memory as
appropriate. The new program uses the debugger's current standard I/O
paths, but can open other paths as necessary. In effect, the debugger
and the program become coroutines.
</para>
        <para>
This command is acknowledged by a register dump showing the
program's initial register values. The <quote>G</quote> command is used to begin
actual program execution. The <quote>E</quote> command will set up the MPU registers
as if you had just performed an F$CHAIN service request as shown below:
<screen>
high    +---------------+ &lt;-- Y
        !               !
        !    parameter  !
        !      area     !
        !               !
        +---------------+ &lt;-- X, SP
        !               !
        !               !
        !   data area   !
        !               !
        !               !
        +---------------+
        !  direct page  !
low     +---------------+ &lt;-- U, DP

        D = Parameter area size
       PC = Module entry point absolute address
       CC = (F=0), (I=0)
</screen>

Example:

<screen>
DB:E myprogram
      SP  CC  A  B DP  X    Y    U    PC
     0CF3 C8 00 01 0C 0CFF 0D00 0C00 9214
DB:
</screen>


</para>
      </section>
      <section>
        <title>Go To Program Command</title>
        <para>
The G (<quote>Go</quote>) command is used to resume execution of a program under test under any of the following circumstances:
</para>
        <orderedlist>
          <listitem>
            <para>
After the <quote>E</quote> command has been used to prepare a new program for execution.
</para>
          </listitem>
          <listitem>
            <para>
To resume program execution after a breakpoint.
</para>
          </listitem>
          <listitem>
            <para>
To resume execution after a <keycombo action="simul"><keycap>CONTROL</keycap><keycap>C</keycap></keycombo> interrupt.
</para>
          </listitem>
        </orderedlist>
        <para>
If the <quote>G</quote> command is used to continue execution after a breakpoint
that has not been removed, the breakpoint will not be reinserted so the
program will not <quote>hang-up</quote>. This features allows you to execute
breakpoints within loops without continually inserting and removing them
if two breakpoints are placed at different addresses within the loop.
</para>
        <para>
You can optionally put an expression after the <quote>G</quote>. The result will
be assigned to the PC register just before execution is resumed in order
to change the re-start address. Here is an example:
</para>
        <screen>
DB:E myprogram <keycap>RETURN</keycap>      <lineannotation>prepare for execution</lineannotation>
    SP  CC  A  B  DP  X    Y    U    PC
    0CF3 C8 00 01 0C 0CFF 0D00 0C00 9214
DB:B 9466 <keycap>RETURN</keycap>           <lineannotation>put breakpoint at 9466</lineannotation>
DB:G <keycap>RETURN</keycap>                <lineannotation>start program</lineannotation>
    BKPT:
    SP  CC  A  B  DP  X    Y    U    PC
    0CEA C0 FF 01 0C 4000 0D00 0C00 9466
DB:G <keycap>RETURN</keycap>                <lineannotation>resume after breakpoint</lineannotation>
</screen>
      </section>
      <section>
        <title><quote>L</quote> Link To Module Command</title>
        <para>
This command (L followed by text) attempts to link to the module
whose name is given in the text line. If successful, Dot is set to the
address of the first byte of the program and is displayed. This command
is commonly used to find the starting address of an OS-9 memory module.
</para>
        <para>
Example:
</para>
        <screen>
DB:L gotoxy <keycap>RETURN</keycap>   <lineannotation>link to module <quote>gotoxy</quote></lineannotation>
    EC00 87
DB:
</screen>
      </section>
    </section>
    <section>
      <title>Utility Commands</title>
      <section>
        <title>Clear and Test Memory Command</title>
        <para>
The <quote>C</quote> command followed by TWO expressions simultaneously performs
a <quote>walking bit</quote> memory test and clears all memory between the two
evaluated addresses. The first expression gives the starting address,
and the second the ending address (which must be higher). If any byte(s)
fail the test, its address is displayed. Of course, only RAM memory can
be tested and cleared.
</para>
        <warning>
          <para>
This command can be dangerous for obvious reasons.
Be sure of what memory you are clearing.
</para>
        </warning>
        <para>
Examples:
</para>
        <screen>
DB:C 1200 15FF <keycap>RETURN</keycap>          <lineannotation>test from 1200 to 15FF</lineannotation>
    12E4                        <lineannotation>indicates bad memory at 12E4 and</lineannotation>
    12E7                        <lineannotation>12E7</lineannotation>
DB:C . .+256 <keycap>RETURN</keycap>            <lineannotation>test from Dot to Dot+256</lineannotation>
DB:                           <lineannotation>indicates no bad memory</lineannotation>
</screen>
      </section>
      <section>
        <title>Dump Memory Command</title>
        <para>
The M command, which is also followed by two addresses, displays a
screen-sized display of memory contents in tabular form in both
hexadecimal and ASCII form. The starting address of each line is printed
on the left, followed by the contents of the subsequent memory locations.
On the far right is the ASCII representation of the same memory
locations. Those locations containing nondisplayable characters have
periods in their place. The high order bit is ignored for the display of
ASCII characters. For example:
</para>
        <screen>
DB:m f100 f17f <keycap>RETURN</keycap>

F100 6225 306C 6120 ED4F 5FED 62ED 6439 E680 b%01a .O_.b.d9..
F110 C130 2504 C139 2303 1A01 39C0 301C F339 .0%..9#...9.0..9
F120 301F 6D61 2706 EC62 1CFE 2004 1A04 1A01 0.ma'..b.. .....
F130 3264 391C FB20 F7A6 8081 2027 FA30 1F39 2d9.. .... '.0.9
F140 3416 A663 3D34 06A6 62E6 643D 3406 A664 4..c=4..b.d=4..d
F150 E667 8D13 A665 E666 8D0D 1CFE EC62 AEE4 .g...e.f.....b..
F160 2702 1A01 3268 393D E363 ED63 2402 6C62 '...2h9=.c.C$.1b
F170 3934 36EC E426 041A 0120 20CC 0010 E764 946..&amp;...  ....d
</screen>
      </section>
      <section>
        <title>Search Memory Command</title>
        <para>
The <quote>S</quote> command is used to search an area of memory for a one or two
byte pattern. The search begins at the present Dot address. The <quote>S</quote> is
followed by two expressions: the first expression is the ending address
of the search, and the second expression is the data to be searched for.
If this value is less than 256, a byte comparison is used, otherwise two
bytes are compared. If a matching pattern is found in memory, Dot is set
to the address where it was located (which is displayed). If no match
occurred, another <quote>DB:</quote> prompt is displayed.
</para>
      </section>
      <section>
        <title>Shell Command</title>
        <para>
This command calls the OS-9 <quote>shell</quote> to execute one or more system
command lines. Its format is a dollar sign optionally followed by a
shell command line. If the command line is given, the shell will execute
just that line and return back to the debugger. If the dollar sign is
immediately followed by an end-of-line, the shell will print prompts for
one or more command lines in its usual manner. You can return to the
(undisturbed) debugger by typing an end-of-file character (usually <keycap>ESCAPE</keycap>).
</para>
        <para>
This command is useful for calling the system utility programs and
the Interactive Assembler from within the debugger. For example:
</para>
        <screen>
DB:$dir <keycap>RETURN</keycap>

DB:$unlink mypgm; mdir e; load test5 <keycap>RETURN</keycap>

DB:$asm myprogram o=myprogram.bin <keycap>RETURN</keycap>
</screen>
      </section>
      <section>
        <title><quote>Q</quote> Quit Debugger Command</title>
        <para>
This command (Q) causes the Interactive Debugger to terminate and
return to OS-9 or the program that called the debugger.
</para>
        <para>
Example:
<screen>
DB: Q <keycap>RETURN</keycap>
OS9:
</screen>


</para>
      </section>
    </section>
    <section>
      <title>Using The Debugger</title>
      <para>
The Interactive Debugger is mostly used for one of three purposes:
</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
To test system memory and I/O devices
</para>
        </listitem>
        <listitem>
          <para>
To <quote>patch</quote> the operating system or other programs
</para>
        </listitem>
        <listitem>
          <para>
To test hand-written or compiler-generated programs.
</para>
        </listitem>
      </itemizedlist>
      <para>
The simple assembly language program shown below is used in some of
the examples in this chapter to illustrate how debug commands are be used
with a real program. The program prints <quote>HELLO WORLD</quote> and then waits for
a line of input.
</para>
      <programlisting xml:id="exampleprg">
                         NAM               EXAMPLE
                         USE   /D0/DEFS/OS9DEFS

                * Data Section
0000                     ORG   0
0000            LINLEN   RMB   2           LINE LENGTH
0002            INPBUF   RMB   80          LINE INPUT BUFFER
0052                     RMB   150         HARDWARE STACK
00E7            STACK    EQU   .-1
00E8            DATMEM   EQU   .           DATA AREA MEMORY SIZE

                * Program Section
0000 87CD0047            MOD   ENDPGM,NAME,$11,$81,ENTRY,DATMEM
000D 4558414D   NAME     PCS   /EXAMPLE/   MODULE NAME STRING

0014            ENTRY    EQU   *           MODULE ENTRY POINT
0014 308D0020            LEAX  OUTSTR,PCR  OUTPUT STRING ADDRESS
0018 108E000C            LDY   #STRLEN     GET STRING LENGTH
001C 8601                LDA   #1          STANDARD OUTPUT PATH
001E 103F8C              OS9   I$WRLN      WRITE THE LINE
0021 2512                BCS   ERROR       BRA IF ANY ERRORS
0023 3042                LEAX  INPBUF,U    ADDR OF INPUT BUFFER
0025 108E0050            LDY   #80         MAX OF 80 CHARACTERS
0029 8600                LDA   #0          STANDARD INPUT PATH
002B 103F88              OS9   I$RDLN      READ THE LINE
002E 2505                BCS   ERROR       BRA IF ANY I/O ERRORS
0030 109F00              STY   LINLEN      SAVE THE LINE LENGTH
0033 C600                LDB   #0          RETURN WITH NO ERRORS
0035 103F06     ERROR    OS9   F$EXIT      TERMINATE THE PROCESS
0038 48454C4C   OUTSTR   FCC   /HELLO WORLD/ OUTPUT STRING
0043 0D                  FCB   $0D         END OF LINE CHARACTER
000C            STRLEN   EQU   *-OUTSTR    STRING LENGTH
0044 268A06              EMOD              END OF MODULE
0047            ENDPGM   EQU   *           END OF PROGRAM
</programlisting>
      <section>
        <title>A Session With The Debugger</title>
        <para>
Below is an example of how DEBUG might be used with the sample
program on the previous page. DEBUG is called from OS-9, the $ command
is used to tell SHELL to load <quote>EXAMPLE</quote> into memory, the <quote>L</quote> command is
used to link to it, etc.
</para>
        <screen>
OS9:DEBUG <keycap>RETURN</keycap>                        <lineannotation>run Debug program</lineannotation>

Interactive Debugger
DB:$LOAD /D1/EXAMPLE <keycap>RETURN</keycap>             <lineannotation>load test program</lineannotation>
DB:L example <keycap>RETURN</keycap>                     <lineannotation>find program start addr.</lineannotation>
    9200 87
DB:. <keycap>RETURN</keycap>                             <lineannotation>display Dot; L set it to</lineannotation>
    9200 87                             <lineannotation>start address</lineannotation>
DB:M . .+44 <keycap>RETURN</keycap>                      <lineannotation>dump program code</lineannotation>

9200 87CD 0047 000D 1181 9300 1400 E845 5841 ...D.........EXA
9210 4D50 4CC5 308D 0020 1083 000C 8601 103F MPL.0.. ....,..?
9220 8C25 1230 4210 8800 5086 0010 3F8B 2505 .%.0B...P...?.%.
9230 109? 00C6 0010 3F06 4845 4C4C 4F20 574F ......?.HELLO WO
9240 524C 440D A484 7F8D D4A6 A02A F639 3432 RLD........*.942

DB:E EXAMPLE <keycap>RETURN</keycap>                     <lineannotation>prepare to run program</lineannotation>
      SP  CC  A  B  DP  X    Y    U    PC
     0DF3 C8 00 01  0D 0DFF 0E00 0D00 9214

DB:B .+ZE <keycap>RETURN</keycap>                        <lineannotation>set breakpoint at 9223</lineannotation>
DB:G <keycap>RETURN</keycap>                             <lineannotation>run program</lineannotation>
HELLO WORLD
hello computer

    BKPT:                               <lineannotation>breakpoint encountered</lineannotation>
     SP  CC  A  B  DP  X    Y    U    PC
    0DF3 C0 00 01  0D 0D02 000F 0D00 922E

DB:M :U :U+20 <keycap>RETURN</keycap>                    <lineannotation>display data area</lineannotation>

0D00 FA31 6865 6C6C 6F20 636F 6D70 7574 6572 .1hello computer
0D10 0DDF C005 E9F1 95FA 4C0D 1DFA 0AC4 5900 ........L.....Y.
0D20 0B64 360B CFB1 0091 F820 SAE2 5AF8 5AF8 .d6...... Z.Z.Z.

DB:. :U+2 <keycap>RETURN</keycap>                        <lineannotation>display relative data</lineannotation>
    0D02 68                             <lineannotation>area offset 2</lineannotation>
DB:<keycap>RETURN</keycap>                               <lineannotation>step through data area</lineannotation>
    0D03 65
DB:<keycap>RETURN</keycap> 
    0D04 6C
DB:<keycap>RETURN</keycap>
    0D05 6C
DB:Q <keycap>RETURN</keycap>                             <lineannotation>quit debugging</lineannotation>
OS9:
</screen>
      </section>
      <section>
        <title>Patching Programs</title>
        <para>
<quote>Patching</quote> (changing the object code of) a program involves four steps:
</para>
        <orderedlist>
          <listitem>
            <para>
Loading the program into memory using OS-9's <quote>LOAD</quote> command.
</para>
          </listitem>
          <listitem>
            <para>
Changing the program in memory using the Debugger's <quote>L</quote> and <quote>=</quote> commands. 
</para>
          </listitem>
          <listitem>
            <para>
Saving the new, patched version of the program on a disk file using the OS-9 <quote>SAVE</quote> command.
</para>
          </listitem>
          <listitem>
            <para>
Updating the program module's CRC check value using the OS-9 <quote>VERIFY</quote> command.
</para>
          </listitem>
        </orderedlist>
        <para>
The fourth step is unique to OS-9 (as compared to other operating
systems) and often overlooked. However, it is essential because OS-9
will refuse to load the patched program into memory until its CRC check
value is updated and correct.
</para>
        <para>
The example that follows shows how the program listed on page 4-1 is
<quote>patched</quote> - this case changing the <quote>LDY #80</quote> instruction to <quote>LDY #32</quote>.
</para>
        <screen>
OS9:load example <keycap>RETURN</keycap>         <lineannotation>load program to be patched</lineannotation>
OS9:debug <keycap>RETURN</keycap>                <lineannotation>run debug</lineannotation>

Interactive Debugger
DB:L EXAMPLE <keycap>RETURN</keycap>             <lineannotation>set dot to start addr of program</lineannotation>
    2000 87                    <lineannotation>note module starts at 2000</lineannotation>
DB:. .+28 <keycap>RETURN</keycap>                <lineannotation>add offset of byte to change</lineannotation>
    2028 50                    <lineannotation>current value is 50</lineannotation>
DB:=#32 <keycap>RETURN</keycap>                  <lineannotation>change to decimal 32</lineannotation>
    2028 10                    <lineannotation>change confirmed</lineannotation>
DB:Q <keycap>RETURN</keycap> quit debugger

OS9:SAVE TEMP EXAMPLE <keycap>RETURN</keycap>    <lineannotation>save patched module on file TEMP</lineannotation>
OS9:VERIFY &lt;TEMP &gt;EX2 <keycap>RETURN</keycap>    <lineannotation>update CRC and copy to file EX2</lineannotation>
OS9:DEL TEMP                   <lineannotation>TEMP no longer needed</lineannotation>
</screen>
        <para>
After the above procedure has been completed, the file EX2 contains
a patched version of the module with a correct module CRC value. It can
be run and/or loaded into memory as desired. 
</para>
      </section>
      <section>
        <title>Patching OS-9 Component Modules</title>
        <para>
Patching modules that are part of OS-9 (modules contained in the
<quote><filename>OS9Boot</filename></quote> file) is a bit trickier than patching regular program because
the <quote>COBBLER</quote> and <quote>OS9GEN</quote> programs must be used to create a new
<quote><filename>OS9Boot</filename></quote> file. The example below shows how an OS-9 <quote>device descriptor</quote>
module is permanently patched, in this case to change the uppercase lock
of the device <quote>/TERM</quote> from <quote>off</quote> to <quote>on</quote>. This example assumes a copy of
the system disk is loaded in drive one (<quote>/D1</quote>).
</para>
        <caution>
          <para>
Always use a <emphasis>copy</emphasis> of your OS-9 system disk when patching it in case something goes wrong!
</para>
        </caution>
        <para>
NOTE: SOME LEVEL TWO SYSTEMS DO NOT PERMIT SYSTEM MODULES TO BE PATCHED -
IN ORDER TO BE CHANGED, THEY MUST BE REASSEMBLED AND INCLUDED IN A NEW BOOT DISK.
</para>
        <screen>
OS9: debug <keycap>RETURN</keycap>            <lineannotation>run debug</lineannotation>

Interactive Debugger
DB: L TERM <keycap>RETURN</keycap>            <lineannotation>set dot to addr of TERM module</lineannotation>
    D300 87                 <lineannotation>(actual address will vary)</lineannotation>
DB: . .+13 <keycap>RETURN</keycap>            <lineannotation>add offset of byte to change</lineannotation>
    D313 00                 <lineannotation>current value is 00</lineannotation>
DB: =1 <keycap>RETURN</keycap>                <lineannotation>change value to 1 for <quote>ON</quote></lineannotation>
    D313 01                 <lineannotation>change confirmed</lineannotation>
DB: Q <keycap>RETURN</keycap>                 <lineannotation>exit debugger</lineannotation>

OS9:COBBLER /D1 <keycap>RETURN</keycap>       <lineannotation>write new bootfile on /D1</lineannotation>
OS9:VERIFY &lt;/D1/OS9BOOT &gt;/D1/TEMP U <keycap>RETURN</keycap>   <lineannotation>update CRC value</lineannotation>
OS9:OS9GEN /D1 <keycap>RETURN</keycap>        <lineannotation>write new bootfile again</lineannotation>
TEMP <keycap>RETURN</keycap>                  <lineannotation>name of file with good CRCs</lineannotation>
<keycap>ESCAPE</keycap>                       <lineannotation>End-of-file key for OS9GEN</lineannotation>
</screen>
      </section>
    </section>
  </section>
</chapter>
