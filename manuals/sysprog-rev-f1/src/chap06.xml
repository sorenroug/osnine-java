<chapter xmlns="http://docbook.org/ns/docbook">
<title>Random Block File Manager</title>

<para>The Random Block File Manager (RBFMAN) is a file manager module
that supports random access block-oriented mass storage devices such
as disk systems, bubble memory systems, and high-performance tape
systems. RBFMAN can handle any number or type of such systems
simultaneously. It is a reentrant subroutine package called by IOMAN
for I/O service requests to random-access devices. It is responsible
for maintaining the logical and physical file structures.
</para>

<para>In the course of normal operation, RBFMAN requests allocation and
deallocation of 256-byte data buffers; usually one is required for
each open file. When physical I/O functions are necessary, RBFMAN
directly calls the subroutines in the associated device drivers. All
data transfers are performed using 256-byte data blocks. RBFMAN does
not directly deal with physical addresses such as tracks, cylinders,
etc. Instead, it passes to device driver modules address parameters
using a standard address called a <quote>logical sector number</quote>,
or <quote>LSN</quote>. LSNs are integers in the range of 0 to n-1, where n is the
maximum number of sectors on the media. The driver is responsible for
translating the logical sector number to actual cylinder/track/sector
values.</para>

<para>Because RBFMAN is designed to support a wide range of devices
having different performance and storage capacity, it is highly
parameter-driven. The physical parameters it uses are stored on the
media itself. On disk systems, this information is written on the
first few sectors of track number zero. The device drivers also use
this information, particularly the physical parameters stored on
sector 0. These parameters are written by the <quote>format</quote> program that
initializes and tests the media.</para>

<sect1>
<title>Logical and Physical Disk Organization</title>

<para>All mass storage volumes (disk media) used by OS-9 utilize the
first few sectors of the volume to store basic identification
structure, and storage allocation information.</para>

<para>Logical sector zero (LSN 0) is called the
<emphasis>Identification Sector</emphasis> which contains description of the
physical and logical format of the volume.</para>

<para>Logical sector one (LSN 1) contains an allocation map which
indicates which disk sectors are free and available for use in new or
expanded files.</para>

<para>The volume's root directory usually starts at logical sector two.</para>

<sect2 xml:id="ident-sector">
<title>Identification Sector</title>

<para>Logical sector number zero contains a description of the physical
and logical characteristics of the volume. These are established by
the <command>format</command> command program when the media is initialized, the
table below gives the OS-9 mnemonic name, byte address, size, and
description of each value stored in this sector.
</para>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="4">
<colspec colwidth="1.2in"/>
<colspec colwidth="0.6in"/>
<colspec colwidth="0.6in" align="right"/>
<colspec colwidth="2.6in"/>
<thead>
<row rowsep="1">
<entry>Name</entry>
<entry>Addr</entry>
<entry>Size</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
    <entry>DD.TOT</entry>
    <entry>$00</entry>
    <entry>3</entry>
    <entry>Total number of sectors on media</entry>
</row>
<row>
    <entry>DD.TKS</entry>
    <entry>$03</entry>
    <entry>1</entry>
    <entry>Number of sectors per track</entry>
</row>
<row>
    <entry>DD.MAP</entry>
    <entry>$04</entry>
    <entry>2</entry>
    <entry>Number of bytes in allocation map</entry>
</row>
<row>
    <entry>DD.BIT</entry>
    <entry>$06</entry>
    <entry>2</entry>
    <entry>Number of sectors per cluster</entry>
</row>
<row>
    <entry>DD.DIR</entry>
    <entry>$08</entry>
    <entry>3</entry>
    <entry>Starting sector of root directory</entry>
</row>
<row>
    <entry>DD.OWN</entry>
    <entry>$0B</entry>
    <entry>2</entry>
    <entry>Owner's user number</entry>
</row>
<row>
    <entry>DD.ATT</entry>
    <entry>$0D</entry>
    <entry>1</entry>
    <entry>Disk attributes</entry>
</row>
<row>
    <entry>DD.DSK</entry>
    <entry>$05</entry>
    <entry>2</entry>
    <entry>Disk identification (for internal use)</entry>
</row>
<row>
    <entry>DD.FMT</entry>
    <entry>$10</entry>
    <entry>1</entry>
    <entry>Disk format: density, number of sides</entry>
</row>
<row>
    <entry>DD.SPT</entry>
    <entry>$11</entry>
    <entry>2</entry>
    <entry>Number of sectors per track</entry>
</row>
<row>
    <entry>DD.RES</entry>
    <entry>$13</entry>
    <entry>2</entry>
    <entry>Reserved for future use</entry>
</row>
<row>
    <entry>DD.BT</entry>
    <entry>$15</entry>
    <entry>3</entry>
    <entry>Starting sector of bootstrap file</entry>
</row>
<row>
    <entry>DD.BSZ</entry>
    <entry>$18</entry>
    <entry>2</entry>
    <entry>Size of bootstrap file (in bytes)</entry>
</row>
<row>
    <entry>DD.DAT</entry>
    <entry>$1A</entry>
    <entry>5</entry>
    <entry>Time of creation: Y:M:D:H:M</entry>
</row>
<row>
    <entry>DD.NAM</entry>
    <entry>$1F</entry>
    <entry>32</entry>
    <entry>Volume name: last char has sign bit set</entry>
</row>
<row>
    <entry>DD.OPT</entry>
    <entry>$3F</entry>
    <entry>32</entry>
    <entry>Option area</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2 xml:id="lsn1">
<title>Disk Allocation Map Sector</title>

<para>One sector (usually LSN 1) of the disk is used for the <quote>disk
allocation map</quote> that specifies which clusters on the disk are
available for allocation of file storage space The address of this
sector is always assigned logical sector 1 by the format program
DD.MAP specifies the number of bytes in this sector which are
actually used in the map.</para>

<para>Each bit in the map corresponds to a cluster of sectors on the
disk. The number of sectors per cluster is specified by the <quote>DD.BIT</quote>
variable in the identification sector, and is always an integral
power of two, i,e., 1, 2, 4, 8, 16, etc. There are a maximum of 2048
bits in the map, so media such as double-density double-sided floppy
disks and hard disks will use a cluster size of two or more sectors.
Each bit is cleared if the corresponding cluster is available for
allocation, or set if the sector is already allocated, non-existent,
or physically defective. The bitmap is initially created by the
<command>format</command> utility program.</para>
</sect2>

<sect2>
<title>File Descriptor Sectors</title>

<para>The first sector of every file is called a <quote>file descriptor</quote>,
which contains the logical and physical description of the file.. The
table below describes the contents of the descriptor.</para>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="4">
<colspec colwidth="0.8in"/>
<colspec colwidth="0.6in"/>
<colspec colwidth="0.6in" align="right"/>
<colspec colwidth="3in"/>
<thead>
<row rowsep="1">
<entry>Name</entry>
<entry>Addr</entry>
<entry>Size</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
    <entry>FD.ATT</entry><entry>$0</entry><entry>1</entry>
    <entry>File Attributes: D S PE PW PR E W R</entry>
</row>
<row>
    <entry>FD.OWN</entry><entry>$1</entry><entry>2</entry>
    <entry>Owner's User ID</entry>
</row>
<row>
    <entry>FD.DAT</entry><entry>$3</entry><entry>5</entry>
    <entry>Date Last Modified; Y M D H M</entry>
</row>
<row>
    <entry>FD.LNK</entry><entry>$8</entry><entry>1</entry>
    <entry>Link Count</entry>
</row>
<row>
    <entry>FD.SIZ</entry><entry>$9</entry><entry>4</entry>
    <entry>File Size (number of bytes)</entry>
</row>
<row>
    <entry>FD.DCR</entry><entry>$D</entry><entry>3</entry>
    <entry>Date Created: Y M D</entry>
</row>
<row>
    <entry>FD.SEG </entry><entry>$10</entry><entry>240</entry>
    <entry>Segment List: see below</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>The attribute byte contains the file permission bits. Bit 7 is set
to indicate a directory file, bit 6 indicates a <quote>sharable</quote>
file, bit 5 is public execute, bit 4 is public write, etc.</para>

<para>The segment list consists of up to 48 five-byte entries that have
the size and address of each block of storage that comprise the file
in logical order. Each entry has a three-byte logical sector number
of the block, and a two-byte block size (in sectors). The entry
following the last segment will be zero.</para>

<para>When a file is created, it initially has no data segments
allocated to it. Write operations past the current end-of-file (the
first write is always past the end-of-file) cause additional sectors
to be allocated to the file. If the file has no segments, it is given
an initial segment having the number of sectors specified by the
minimum allocation entry in the device descriptor, or the number of
sectors requested if greater than the minimum. Subsequent expansions
of the file are also generally made in minimum allocation increments.
An attempt is made to expand the last segment wherever possible
rather than adding a new segment. When the file is closed, unused
sectors in the last segment are truncated.</para>

<para>A note about disk allocation: OS-9 attempts to minimize the number
of storage segments used in a file. In fact, many files will only
have one segment in which case no extra read operations are needed to
randomly access any byte on the file. Files can have multiple
segments if the free space of the disk becomes very fragmented, or if
a file is repeatedly closed, then opened and expanded at some later
time. This can be avoided by writing a byte at the highest address to
be used on a file before writing any other data.</para>
</sect2>

<sect2>
<title>Directory Files</title>

<para>Disk directories are files that have the <quote>D</quote> attribute
set. Directory files contain an integral number of directory entries
each of which can bold the name and LSN of a single regular or
directory file.</para>

<para>Each directory entry is 32 bytes long, consisting of 29 bytes for
the file name followed by a three byte logical sector number of the
file's descriptor sector. The file name is left-justified in the
field with the sign bit of the last character set. Unused entries
have a zero byte in the first file name character position.</para>

<para>Every mass-storage media must have a master directory called the
<quote>root directory</quote>. The beginning logical sector number of
this directory is stored in the identification sector, as previously
described.</para>
</sect2>
</sect1>

<sect1>
<title>RBFMAN Definitions of the Path Descriptor.</title>

<para>The table below describes the usage of the file-manager-reserved
section of path descriptors used by RBFMAN.</para>

<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="4">
<colspec colwidth="1in" colname="c1"/>
<colspec colwidth="0.6in"/>
<colspec colwidth="0.6in" align="right"/>
<colspec colwidth="2.8in" colname="c4"/>
<spanspec spanname="all" namest="c1" nameend="c4"/>
<thead>
<row rowsep="1">
    <entry>Name</entry>
    <entry>Addr</entry>
    <entry>Size</entry>
    <entry>Description</entry>
</row>
</thead>
<tbody>
<row>
    <entry spanname="all">Universal Section (same for all file managers)</entry>
</row>
<row>
    <entry>PD.PD</entry>
    <entry>$00</entry>
    <entry>1</entry>
    <entry>Path number</entry>
</row>
<row>
    <entry>PD.MOD</entry>
    <entry>$01</entry>
    <entry>1</entry>
    <entry>Mode (read/write/update)</entry>
</row>
<row>
    <entry>PD.CNT</entry>
    <entry>$02</entry>
    <entry>1</entry>
    <entry>Number of open images</entry>
</row>
<row>
    <entry>PD.DEV</entry>
    <entry>$03</entry>
    <entry>2</entry>
    <entry>Address of device table entry</entry>
</row>
<row>
    <entry>PD.CPR</entry>
    <entry>$05</entry>
    <entry>1</entry>
    <entry>Current process ID</entry>
</row>
<row>
    <entry>PD.RGS</entry>
    <entry>$06</entry>
    <entry>2</entry>
    <entry>Address of callers register stack</entry>
</row>
<row>
    <entry>PD.BUF</entry>
    <entry>$08</entry>
    <entry>2</entry>
    <entry>Buffer address</entry>
</row>
<row>
    <entry spanname="all">RBFMAN Path Descriptor Definitions</entry>
</row>
<row>
    <entry>PD.SMF</entry>
    <entry>$0A</entry>
    <entry>1</entry>
    <entry>State flags (see next page)</entry>
</row>
<row>
    <entry>PD.CP</entry>
    <entry>$0B</entry>
    <entry>4</entry>
    <entry>Current logical file position (byte addr)</entry>
</row>
<row>
    <entry>PD.SIZ</entry>
    <entry>$0F</entry>
    <entry>4</entry>
    <entry>File size</entry>
</row>
<row>
    <entry>PD.SBL</entry>
    <entry>$13</entry>
    <entry>3</entry>
    <entry>Segment beginning logical sector number</entry>
</row>
<row>
    <entry>PD.SBP</entry>
    <entry>$16</entry>
    <entry>3</entry>
    <entry>Segment beginning physical sector number</entry>
</row>
<row>
    <entry>PD.SSZ</entry>
    <entry>$19</entry>
    <entry>2</entry>
    <entry>Segment size</entry>
</row>
<row>
    <entry>PD.DSK</entry>
    <entry>$15</entry>
    <entry>2</entry>
    <entry>Disk ID (for internal use only)</entry>
</row>
<row>
    <entry>PD.DTB</entry>
    <entry>$lD</entry>
    <entry>2</entry>
    <entry>Address of drive table</entry>
</row>
<row>
    <entry spanname="all">RBFMAN Option Section Definitions (Copied from device descriptor)</entry>
</row>
<row>
    <entry></entry>
    <entry>$20</entry>
    <entry>1</entry>
    <entry>Device class 0=SCF 1=NSF 2=PIPE 3=SBF</entry>
</row>
<row>
    <entry>PD.DRV</entry>
    <entry>$21</entry>
    <entry>1</entry>
    <entry>Drive number (0..N)</entry>
</row>
<row>
    <entry>PD.STP</entry>
    <entry>$22</entry>
    <entry>1</entry>
    <entry>Step rate</entry>
</row>
<row>
    <entry>PD.TYV</entry>
    <entry>$23</entry>
    <entry>1</entry>
    <entry>Device type</entry>
</row>
<row>
    <entry>PD.UNS</entry>
    <entry>$24</entry>
    <entry>1</entry>
    <entry>Density capability</entry>
</row>
<row>
    <entry>PD.CYL</entry>
    <entry>$25</entry>
    <entry>2</entry>
    <entry>Number of cylinders (tracks)</entry>
</row>
<row>
    <entry>PD.SID</entry>
    <entry>$27</entry>
    <entry>1</entry>
    <entry>Number of sides (surfaces)</entry>
</row>
<row>
    <entry>PD.VFY</entry>
    <entry>$28</entry>
    <entry>1</entry>
    <entry>0 = verify disk writes</entry>
</row>
<row>
    <entry>PD.SCT</entry>
    <entry>$29</entry>
    <entry>2</entry>
    <entry>Default number of sectors/track</entry>
</row>
<row>
    <entry>PD.T0S</entry>
    <entry>$2B</entry>
    <entry>2</entry>
    <entry>Default number of sectors/track (track 0)</entry>
</row>
<row>
    <entry>PD.ILV</entry>
    <entry>$2D</entry>
    <entry>1</entry>
    <entry>Sector interleave factor</entry>
</row>
<row>
    <entry>PD.SAS</entry>
    <entry>$2E</entry>
    <entry>1</entry>
    <entry>Segment allocation size</entry>
</row>
<row>
    <entry spanname="all">(the following values are <emphasis>not</emphasis> copied from the device descriptor)</entry>
</row>
<row>
    <entry>PD.ATT</entry>
    <entry>$33</entry>
    <entry>1</entry>
    <entry>File attributes (D S PE PW PR E W R)</entry>
</row>
<row>
    <entry>PD.FD</entry>
    <entry>$34</entry>
    <entry>3</entry>
    <entry>File descriptor PSN (physical sector #)</entry>
</row>
<row>
    <entry>PD.DFD</entry>
    <entry>$37</entry>
    <entry>3</entry>
    <entry>Directory file descriptor PSN</entry>
</row>
<row>
    <entry>PD.DCP</entry>
    <entry>$3A</entry>
    <entry>4</entry>
    <entry>File's directory entry pointer</entry>
</row>
<row>
    <entry>PD.DVT</entry>
    <entry>$3E</entry>
    <entry>2</entry>
    <entry>Address of device table entry</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
State Flag (PD.SMF): the bits of this byte are defined as: 
</para>
<literallayout>
bit 0 = set if current buffer has been altered
bit 1 = set if current sector is in buffer
bit 2 = set if descriptor sector in buffer
</literallayout>

<para>The first section of the path descriptor is universal for all file
managers, the second and third sections are defined by RBFMAN and
RBFMAN-type device drivers. The option section of the path descriptor
contains many device operating parameters which may be read and/or
written by the OS9 <xref linkend="i.getstt"/>
and <xref linkend="i.setstt"/> service requests. This section
is initialized by IOMAN which copies the initialization table of the
device descriptor into the option section of the path descriptor when
a path to a device is opened. Any values not determined by this table
will default to zero.</para>
</sect1>

<sect1>
<title>RBF Device Descriptor Modules</title>

<para>This section describes the definitions and use of the
initialization table contained in device descriptor modules for
RBF-type devices.</para>

<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="4">
<colspec colwidth="1in"/>
<colspec colwidth="0.7in"/>
<colspec colwidth="0.7in"/>
<colspec colwidth="4in"/>
<thead>
<row>
    <entry>Module Offset</entry>
    <entry></entry>
    <entry></entry>
    <entry></entry>
</row>
</thead>
<tbody>
<row>
    <entry>0-$11</entry>
    <entry></entry>
    <entry></entry>
    <entry>Standard Device Descriptor Module Header</entry>
</row>
<row>
    <entry>$12</entry>
    <entry>IT.DTP</entry>
    <entry>RMB 1</entry>
    <entry>DEVICE TYPE (0=SCF 1=RBF 2=PIPE 3=SBF)</entry></row>
<row>
    <entry>$13</entry>
    <entry>IT.DRV</entry>
    <entry>RMB 1</entry>
    <entry>DRIVE NUMBER</entry></row>
<row>
    <entry>$14</entry>
    <entry>IT.STP</entry>
    <entry>RMB 1</entry>
    <entry>STEP RATE</entry></row>
<row>
    <entry>$15</entry>
    <entry>IT.TYP</entry>
    <entry>RMB 1</entry>
    <entry>DEVICE TYPE (See RBFMAN path descriptor)</entry></row>
<row>
    <entry>$16</entry>
    <entry>IT.DNS</entry>
    <entry>RMB 1</entry>
    <entry>MEDIA DENSITY (0 - SINGLE, 1-DOUBLE)</entry></row>
<row>
    <entry>$17</entry>
    <entry>IT.CYL</entry>
    <entry>RMB 2</entry>
    <entry>NUMBER OF CYLINDERS (TRACKS)</entry></row>
<row>
    <entry>$19</entry>
    <entry>IT.SID</entry>
    <entry>RMB 1</entry>
    <entry>NUMBER OF SURFACES (SIDES)</entry></row>
<row>
    <entry>$1A</entry>
    <entry>IT.VFY</entry>
    <entry>RMB 1</entry>
    <entry>0 = VERIFY DISK WRITES</entry></row>
<row>
    <entry>$1B</entry>
    <entry>IT.SCT</entry>
    <entry>RMB 2</entry>
    <entry>Default Sectors/Track</entry></row>
<row>
    <entry>$1D</entry>
    <entry>IT.T0S</entry>
    <entry>RMB 2</entry>
    <entry>Default Sectors/Track (Track 0)</entry></row>
<row>
    <entry>$1F</entry>
    <entry>IT.ILV</entry>
    <entry>RMB 1</entry>
    <entry>SECTOR INTERLEAVE FACTOR</entry>
</row>
<row>
    <entry>$20</entry>
    <entry>IT.SAS</entry>
    <entry>RMB 1</entry>
    <entry>SEGMENT ALLOCATION SIZE</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
IT.DRV - This location is used to associate a one byte integer
with each drive that a controller will handle. The drives for each
controller should be numbered 0 to n-1, where n is the maximum number
of drives the controller can handle.</para>

<para>IT.STP - (Floppy disks) This location sets the head stepping rate
that will be used with a drive. The step rate should be set to the
fastest value that the drive is capable of to reduce access time. The
actual values stored depended on the specific disk controller and
disk driver module used. Below are the values which are used by the
popular Western Digital floppy disk controller IC:</para>

<informaltable frame="all">
<tgroup cols="5">
<colspec colwidth="1in" colname="q1" align="center"/>
<colspec colwidth="1.2in" colname="q2" align="right"/>
<colspec colwidth="1.2in" colname="q3" align="right"/>
<colspec colwidth="1.2in" colname="q4" align="right"/>
<colspec colwidth="1.2in" colname="q5" align="right"/>
<spanspec spanname="x1" namest="q2" nameend="q3"/>
<spanspec spanname="x2" namest="q4" nameend="q5"/>
<thead>
<row>
    <entry>Step Code</entry>
    <entry spanname="x1" align="center">FD1771</entry>
    <entry spanname="x2" align="center">FD179X Family</entry>
</row>
</thead>
<tbody>
<row>
    <entry></entry>
    <entry>5"</entry>
    <entry>8"</entry>
    <entry>5"</entry>
    <entry>8"</entry>
</row>
<row>
    <entry>0</entry>
    <entry>40ms</entry>
    <entry>20ms</entry>
    <entry>30ms</entry>
    <entry>15ms</entry>
</row>
<row>
    <entry>1</entry>
    <entry>20ms</entry>
    <entry>10ms</entry>
    <entry>20ms</entry>
    <entry>10ms</entry>
</row>
<row>
    <entry>2</entry>
    <entry>12ms</entry>
    <entry>6ms</entry>
    <entry>12ms</entry>
    <entry>6ms</entry>
</row>
<row>
    <entry>3</entry>
    <entry>12ms</entry>
    <entry>6ms</entry>
    <entry>6ms</entry>
    <entry>3ms</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<literallayout>
IT.TYP - Device type (All types)
    bit 0 -- 0 = 5&quot; floppy disk
             1 = 8&quot; floppy disk
    bit 6 -- 0 = Standard OS-9 format
             1 = Non-standard format
    bit 7 -- 0 = Floppy disk
             1 = Hard disk

IT.DNS - Density capabilities (Floppy disk only)
    bit 0 -- 0 = Single bit density (FM)
             1 = Double bit density (MFM)

    bit 1 -- 0 = Single track density (5&quot;, 48 TPI)
             1 = Double track density (5&quot;, 96 TPI)
</literallayout>

<para>IT.SAS - This value specifies the minimum number of sectors to
be allocated at any one time.</para>
</sect1>

<sect1>
<title>RBF-type Device Drivers</title>

<para>An RBF type device driver module contains a package of subroutines
that perform sector oriented I/O to or from a specific hardware
controller. These modules are usually reentrant so that one copy of
the module can simultaneously run several different devices that use
identical I/O controllers. IOMAN will allocate a static storage area
for each device (which may control several drives). The size of the
storage area is given in the device driver module header. Some of
this storage area will be used by IOMAN and RBFMAN, the device driver
is free to use the remainder in any manner. This static storage is
used as follows: 
</para>
<table frame="none" rowsep="0" colsep="0">
<title>Static Storage Definitions</title>
<tgroup cols="4">
<colspec colwidth="0.6in" colname="c1"/>
<colspec colwidth="0.7in" colname="c2"/>
<colspec colwidth="1.2in" colname="c3"/>
<colspec colwidth="2.5in" colname="c4"/>
<spanspec spanname="x1" namest="c1" nameend="c2"/>
<spanspec spanname="x2" namest="c3" nameend="c4"/>
<thead>
<row>
    <entry spanname="x1">Offset</entry>
    <entry spanname="x2">ORG 0</entry>
</row>
</thead>
<tbody>
<row>
<entry>0</entry>
<entry>V.PAGE</entry>
<entry>RMB 1</entry>
<entry>PORT EXTENDED ADDRESS (A20 - A16)</entry>
</row>
<row>
<entry>1</entry>
<entry>V.PORT </entry>
<entry>RMB 2</entry>
<entry>DEVICE BASE ADDRESS</entry>
</row>
<row>
<entry>3</entry>
<entry>V.LPRC</entry>
<entry>RMB 1</entry>
<entry>LAST ACTIVE PROCESS ID</entry>
</row>
<row>
<entry>4</entry>
<entry>V.BUSY</entry>
<entry>RMB 1</entry>
<entry>ACTIVE PROCESS ID (0 = NOT BUSY)</entry>
</row>
<row>
<entry>5</entry>
<entry>V.WAKE</entry>
<entry>RMB 1</entry>
<entry>PROCESS ID TO REAWAKEN</entry>
</row>
<row>
<entry></entry>
<entry>V.USER</entry>
<entry>EQU .</entry>
<entry>END OF OS9 DEFINITIONS</entry>
</row>
<row>
<entry>6</entry>
<entry>V.NDRV</entry>
<entry>RMB 1</entry>
<entry>NUMBER OF DRIVES</entry>
</row>
<row>
<entry></entry>
<entry>DRVBEG</entry>
<entry>EQU .</entry>
<entry>BEGINNING OF DRIVE TABLES</entry>
</row>
<row>
<entry>7</entry>
<entry>TABLES</entry>
<entry>RMB DRVMEM*N</entry>
<entry>RESERVE N DRIVE TABLES</entry>
</row>
<row>
<entry></entry>
<entry></entry>
<entry>RMB 1</entry>
<entry></entry>
</row>
<row>
<entry></entry>
<entry>FREE</entry>
<entry>EQU </entry>
<entry>FREE FOR DRIVER TO USE</entry>
</row>
</tbody>
</tgroup>
</table>

<note><para>V.PAGE through V.USER are predefined in the
<filename>OS9Defs</filename> file.
V.NDRV, DRVBEG, DRVMEM are predefined in the <filename>RBFDefs</filename>
file.</para></note>

<para>V.PAGE, V.PORT These three bytes are defined by IOMAN as the 24-bit
device address.</para>

<para>V.LPRC This location contains the process ID of the last process
to use the device. Not used by RBF-type device drivers.</para>

<para>V.BUSY This location contains the process ID of the process
currently using the device. Defined by RBFMAN.</para>

<para>V.WAKE This location contains the process-ID of any process that
is waiting for the device to complete I/O (0 = NO PROCESS WAITING).
Defined by device driver.</para>

<para>V.NDRV This location contains the number of drives that the
controller can use. Defined by the device driver as the maximum
number of drives that the controller can work with. RBFMAN will
assume that there is a drive table for each drive. Also see the
driver INIT routine in this section.</para>

<para>TABLES This area contains one table for each drive that the
controller will handle (RBFMAN will assume that there are as many
tables as indicated by V.NDRV). Some time after the driver INIT
routine has been called, RBFMAN will issue a request for the driver
to read the identification sector (logical sector zero) from a drive.
At this time the driver will initialize the corresponding drive table
by copying the first part of the identification sector (up to
DD.SIZ) into it, Also see the
<quote><link linkend="ident-sector">Identification Sector</link></quote> section of
this manual. The format of each drive table is as given below:</para>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="4">
<colspec colwidth="0.6in" colname="c1"/>
<colspec colwidth="0.7in" colname="c2"/>
<colspec colwidth="1.2in" colname="c3"/>
<colspec colwidth="2.5in" colname="c4"/>
<spanspec spanname="x1" namest="c1" nameend="c2"/>
<spanspec spanname="x2" namest="c3" nameend="c4"/>
<thead>
<row>
    <entry spanname="x1">Offset</entry>
    <entry spanname="x2">ORG 0</entry>
</row>
</thead>
<tbody>
<row>
    <entry>$00</entry>
    <entry>DD.TOT</entry>
    <entry>RMB 3</entry>
    <entry>Total number of sectors on media</entry>
</row>
<row>
    <entry>$03</entry>
    <entry>DD.TKS</entry>
    <entry>RMB 1</entry>
    <entry>Number of sectors per track</entry>
</row>
<row>
    <entry>$04</entry>
    <entry>DD.MAP</entry>
    <entry>RMB 2</entry>
    <entry>Number of bytes in allocation map</entry>
</row>
<row>
    <entry>$06</entry>
    <entry>DD.BIT</entry>
    <entry>RMB 2</entry>
    <entry>Number of sectors per cluster</entry>
</row>
<row>
    <entry>$08</entry>
    <entry>DD.DIR</entry>
    <entry>RMB 3</entry>
    <entry>Starting sector of root directory</entry>
</row>
<row>
    <entry>$0B</entry>
    <entry>DD.OWN</entry>
    <entry>RMB 2</entry>
    <entry>Owner's user number</entry>
</row>
<row>
    <entry>$0D</entry>
    <entry>DD.ATT</entry>
    <entry>RMB 1</entry>
    <entry>Disk attributes</entry>
</row>
<row>
    <entry>$0E</entry>
    <entry>DD.DSK</entry>
    <entry>RMB 2</entry>
    <entry>Disk identification</entry>
</row>
<row>
    <entry>$10</entry>
    <entry>DD.FMT</entry>
    <entry>RMB 1</entry>
    <entry>Disk format: density, number of sides</entry>
</row>
<row>
    <entry>$11</entry>
    <entry>DD.SPT</entry>
    <entry>RMB 2</entry>
    <entry>Number of sectors per track</entry>
</row>
<row>
    <entry>$13</entry>
    <entry>DD.RES</entry>
    <entry>RMB 2</entry>
    <entry>Reserved for future use</entry>
</row>
<row>
    <entry></entry>
    <entry>DD.SIZ</entry>
    <entry>EQU .</entry>
    <entry></entry>
</row>
<row>
    <entry>$15</entry>
    <entry>V.TRAK</entry>
    <entry>RMB 2</entry>
    <entry>Current Track Number</entry>
</row>
<row>
    <entry>$17</entry>
    <entry>V.BMB</entry>
    <entry>RMB 1</entry>
    <entry>Bit-map Use Flag</entry>
</row>
<row>
    <entry>$18</entry>
    <entry>DRVMEM</entry>
    <entry>EQU .</entry>
    <entry>Size of Each Drive Table</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>DD.TOT This location contains the total number of
sectors contained on the disk.</para>

<para>DD.TKS This location contains the track size (in sectors).</para>

<para>DD.MAP This location contains the
number of bytes in the disk allocation bit map.</para>

<para>DD.BIT This location contains the number of sectors that each bit
represents in the disk allocation bit map.</para>

<para>DD.DIR This location contains the logical sector number of the disk root directory.</para>

<para>DD.OWN This location contains the disk owner's user number.</para>

<para>DD.ATT This location contains the disk access permission attributes as defined
below:</para>

<literallayout>
BIT 7 - D (DIRECTORY IF SET)
BIT 6 - S (SHARABLE IF SET)
BIT 5 - PX (PUBLIC EXECUTE IF SET)
BIT 4 - PW (PUBLIC WRITE IF SET)
BIT 3 - PR (PUBLIC READ IF SET)
BIT 2 - X (EXECUTE IF SET)
BIT 1 - W (WRITE IF SET).
BIT 0 - R (READ IF SET)
</literallayout>

<para>
DD.DSK This location contains a pseudo random number which is
used to identify a disk so that OS-9 may detect when a disk is
removed from the drive and another inserted in its place.</para>

<para>DD.FMT DISK FORMAT:</para>
<literallayout>
BIT B0 - SIDE
    0 = SINGLE SIDED
    1 = DOUBLE SIDED

BIT B1 - DENSITY
    0 = SINGLE DENSITY
    1 = DOUBLE DENSITY

BIT B2 - TRACK DENSITY
    0 = SINGLE (48 TPI)
    1= DOUBLE (96 TPI)
</literallayout>

<para>DD.SPT Number of sectors per track (track zero may use a different
value, specified by IT.T0S in the device descriptor).</para>

<para>DD.RES RESERVED FOR FUTURE USE</para>

<para>V.TRAK This location contains the current track which the head is
on and is updated by the driver.</para>

<para>V.BMB This location is used by RBFMAN to indicate whether or not
the disk allocation bit map is currently in use (0 = not in use). The
disk driver routines must not alter this location.</para>
</sect1>

<sect1>
<title>RBFMAN Device Drivers</title>

<para>As with all device drivers, RBFMAN-type device drivers use a
standard executable memory module format with a module type of
<quote>device driver</quote> (CODE $E). The execution offset address in
the module header points to a branch table that has six three byte
entries. Each entry is typically a LBRA to the corresponding
subroutine. The branch table is defined as follows:
</para>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="4">
<colspec colwidth="0.8in"/>
<colspec colwidth="0.8in"/>
<colspec colwidth="0.8in"/>
<colspec colwidth="1.6in"/>
<tbody>
<row>
	<entry morerows="5">ENTRY</entry>
	<entry>LBRA</entry>
	<entry>INIT</entry>
	<entry>INITIALIZE DRIVE</entry>
</row>
<row>
	<entry>LBRA</entry>
	<entry>READ</entry>
	<entry>READ SECTOR</entry>
</row>
<row>
	<entry>LBRA</entry>
	<entry>WRITE</entry>
	<entry>WRITE SECTOR</entry>
</row>
<row>
	<entry>LBRA</entry>
	<entry>GETSTA</entry>
	<entry>GET STATUS</entry>
</row>
<row>
	<entry>LBRA</entry>
	<entry>SETSTA</entry>
	<entry>SET STATUS</entry>
</row>
<row>
	<entry>LBRA</entry>
	<entry>TERM</entry>
	<entry>TERMINATE DEVICE</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>Each subroutine should exit with the condition code register C bit
cleared if no error occurred. Otherwise the C bit should be set and
an appropriate error code returned in the B register. Below is a
description of each subroutine, its input parameters, and its output
parameters.</para>

<sect2>
<title>NAME: INIT</title>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>INIT</entry>
</row>
<row>
	<entry>INPUT:</entry>
	<entry><literallayout>(U) = ADDRESS OF DEVICE STATIC STORAGE
(Y) = ADDRESS OF THE DEVICE DESCRIPTOR MODULE</literallayout></entry>
</row>
<row>
	<entry>OUTPUT:</entry>
	<entry>NONE</entry>
</row>
<row>
	<entry>ERROR OUTPUT:</entry>
	<entry><literallayout>(CC) = C bit set.
(B) = Appropriate error code.</literallayout></entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>INITIALIZE DEVICE AND ITS STATIC STORAGE AREA</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<orderedlist  numeration="arabic">
	<listitem><para>If disk writes are verified, use the
        <xref linkend="f.srqmem"/> service request
	to allocate a 256 byte buffer area where a sector may be read back
	and verified after a write.</para></listitem>
	<listitem><para>Initialize the device permanent storage. For floppy disk
	controller typically this consists of initializing V.NDRV to the
	number of drives that the controller will work with, initializing
	DD.TOT in the drive table to a non-zero value so that sector zero
	may be read or written to, and initializing V.TRAK to $FF so that
	the first seek will find track zero.</para></listitem>
	<listitem><para>Place the IRQ service routine on the IRQ polling list by
	using the OS9 <xref linkend="f.irq"/> service request.</para></listitem>
	<listitem><para>Initialize the device control registers (enable interrupts if
	necessary).</para></listitem>
</orderedlist>

<note>
    <para>Prior to being called, the device permanent storage will be
    cleared (set to zero) except for V.PAGE and V.PORT which will contain
    the 24 bit device address. The driver should initialize each drive
    table appropriately for the type of disk the driver expects to be
    used on the corresponding drive.</para>
</note>
</sect2>

<sect2>
<title>NAME: READ</title>

<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>READ</entry>
</row>
<row>
	<entry>INPUT:</entry>
	<entry><literallayout>(U) = ADDRESS OF THE DEVICE STATIC STORAGE
(Y) = ADDRESS OF THE PATH DESCRIPTOR
(B) = MSB OF DISK LOGICAL SECTOR NUMBER
(X) = LSB's OF DISK LOGICAL SECTOR NUMBER</literallayout></entry>
</row>
<row>
	<entry>OUTPUT:</entry>
	<entry>SECTOR IS RETURNED IN THE SECTOR BUFFER</entry>
</row>
<row>
	<entry>ERROR OUTPUT:</entry>
	<entry><literallayout>(CC) = C bit set.
(B) = Appropriate error code.</literallayout></entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>READ A 256 BYTE SECTOR</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
Read a sector from the disk and place it in the sector buffer
(256 byte). Below are the things that the disk driver must do:</para>

<para>1. Get the sector buffer address from PD.BUF in the path descriptor.</para>

<para>2. Get the drive number from PD.DRV in the path descriptor.</para>

<para>3. Compute the physical disk address from the logical sector number.</para>

<para>4. Initiate the read operation.</para>

<para>5. Copy V.BUSY to V.WAKE, then go to sleep and wait for the I/O to
complete (the IRQ service routine is responsible for sending a wake
up signal). After awakening, test V.WAKE to see if it is clear, if
not, go back to sleep.</para>

<para>If the disk controller can not be interrupt driven it will be
necessary to perform programmed I/O.</para>

<para>NOTE 1: Whenever logical sector zero is read, the first part
of this sector must be copied into the proper drive table (get the
drive number from PD.DRV in the path descriptor). The number of bytes
to copy is DD.SIZ.</para>

<para>NOTE 2: The drive number (PD.DRV) should be used to compute
the offset to the corresponding drive table as follows:</para>

<programlisting>
LDA PD.DRV.Y Get drive number
LDB #DRVMEM Get size of a drive table
MUL
LEAX DRVBEG,U Get address of first table
LEAX D,X           Compute address of table N
</programlisting>
</sect2>

<sect2>
<title>NAME: WRITE</title>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>WRITE</entry>
</row>
<row>
	<entry>INPUT:</entry>
	<entry><literallayout>(U) = ADDRESS OF THE DEVICE STATIC STORAGE
(Y) = ADDRESS OF THE PATH DESCRIPTOR
(B) = MSB OF DISK LOGICAL SECTOR NUMBER
(X) = LSB's OF DISK LOGICAL SECTOR NUMBER</literallayout></entry>
</row>
<row>
	<entry>OUTPUT:</entry>
	<entry>THE SECTOR BUFFER IS WRITTEN OUT TO DISK</entry>
</row>
<row>
	<entry>ERROR OUTPUT:</entry>
	<entry><literallayout>(CC) = C bit set.
(B) = Appropriate error code.</literallayout></entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>WRITE A SECTOR</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>Write the sector buffer (256 bytes) to the disk. Below are the
things that a disk driver must do:</para>

<para>1. Get the sector buffer address from PD.BUF in the path
descriptor.</para>

<para>2. Get the drive number from PD.DRV in the path descriptor.</para>

<para>3. Compute the physical disk address from the logical sector number.</para>

<para>4. Initiate the write operation.</para>

<para>5. Copy V.BUSY to V.WAKE, then go to sleep and wait for the I/O
to complete (the IRQ service routine is responsible for sending the
wakeup signal). After awakening, test V.WAKE to see if it is clear,
if it is not, then go back to sleep. If the disk controller can not
be interrupt-driven, it will be necessary to perform a programmed I/O
transfer.</para>

<para>6. If PD.VFY in the path descriptor is equal to zero, read the
sector back in and verify that it was written correctly. This usually
does not involve a compare of the data.</para>

<para>NOTE 1: If disk writes are to be verified, the INIT routine must
request the buffer where the sector may be placed when it is read
back in. Do not copy sector zero into the drive table when it is read
back to be verified.</para>

<para>NOTE 2: Use the drive number (PD.DRV) to compute the offset to the
corresponding drive table as shown for the READ routine.</para>
</sect2>

<sect2>
<title>NAME: GETSTA PUTSTA</title>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>GETSTA/PUTSTA</entry>
</row>
<row>
	<entry>INPUT:</entry>
	<entry><literallayout>(U) = ADDRESS OF THE DEVICE STATIC STORAGE AREA
(Y) = ADDRESS OF THE PATH DESCRIPTOR
(B) = STATUS CODE</literallayout></entry>
</row>
<row>
	<entry>OUTPUT:</entry>
	<entry>(DEPENDS UPON THE FUNCTION CODE)</entry>
</row>
<row>
	<entry>ERROR OUTPUT:</entry>
	<entry><literallayout>(CC) = C bit set.
(B) = Appropriate error code.</literallayout></entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>GET/SET DEVICE STATUS</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>These routines are wild card calls used to get (set) the device's
operating parameters as specified for the OS9 <xref linkend="i.getstt"/>
and <xref linkend="i.setstt"/>
service requests.</para>

<para>It may be necessary to examine or change the register stack which
contains the values of MPU registers at the time of the
<xref linkend="i.getstt"/> or
<xref linkend="i.setstt"/> service request. The address of the register stack may be
found in PD.RGS, which is located in the path descriptor, . The
following offsets may be used to access any particular value in the
register stack:</para>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="5">
<colspec colwidth="0.6in"/>
<colspec colwidth="0.8in"/>
<colspec colwidth="0.5in"/>
<colspec colwidth="0.3in" colname="c4"/>
<colspec colwidth="2.5in" colname="c5"/>
<thead>
    <row>
	<entry>OFFSET</entry>
	<entry align="left" nameend="c4">MNEMONIC</entry>
	<entry namest="c5">MPU REGISTER</entry>
    </row>
</thead>
<tbody>
<row>
    <entry>$0</entry>
    <entry>R$CC</entry>
    <entry>RMB</entry>
    <entry>1</entry>
    <entry>CONDITIONS CODE REGISTER</entry>
</row>
<row>
    <entry>$1</entry>
    <entry>R$D</entry>
    <entry>EQU</entry>
    <entry>.</entry>
    <entry>D REGISTER</entry>
</row>
<row>
    <entry>$1</entry>
    <entry>R$A</entry>
    <entry>RMB</entry>
    <entry>1</entry>
    <entry>A REGISTER</entry>
</row>
<row>
    <entry>$2</entry>
    <entry>R$B</entry>
    <entry>RMB</entry>
    <entry>1</entry>
    <entry>B REGISTER</entry>
</row>
<row>
    <entry>$3</entry>
    <entry>R$DP</entry>
    <entry>RMB</entry>
    <entry>1</entry>
    <entry>DP REGISTER</entry>
</row>
<row>
    <entry>$4</entry>
    <entry>R$X</entry>
    <entry>RMB</entry>
    <entry>2</entry>
    <entry>X REGISTER</entry>
</row>
<row>
    <entry>$6</entry>
    <entry>R$Y</entry>
    <entry>RMB</entry>
    <entry>2</entry>
    <entry>Y REGISTER</entry>
</row>
<row>
    <entry>$8</entry>
    <entry>R$U</entry>
    <entry>RMB</entry>
    <entry>2</entry>
    <entry>U REGISTER</entry>
</row>
<row>
    <entry>$A</entry>
    <entry>R$PC</entry>
    <entry>RMB</entry>
    <entry>2</entry>
    <entry>PROGRAM COUNTER</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</sect2>

<sect2>
<title>NAME: TERM</title>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>TERM</entry>
</row>
<row>
	<entry>INPUT:</entry>
	<entry>(U) = ADDRESS OF DEVICE STATIC STORAGE AREA</entry>
</row>
<row>
	<entry>OUTPUT:</entry>
	<entry>NONE</entry>
</row>
<row>
	<entry>ERROR OUTPUT:</entry>
	<entry><literallayout>(CC) = C bit set.
(B) = Appropriate error code.</literallayout></entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>TERMINATE DEVICE</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>This routine is called when a device is no longer in use in the
system, which is defined to be when the link count of its device
descriptor module becomes zero). The TERM routine must:</para>

<para>1. Wait until any pending I/O has completed.</para>

<para>2. Disable the device interrupts.</para>

<para>3. Remove the device from the IRQ polling list.</para>

<para>4. If the INIT routine reserved a 256 byte buffer for verifying
disk writes, return the memory with the <xref linkend="f.mem"/> service request.</para>
</sect2>

<sect2>
<title>NAME: IRQ SERVICE ROUTINE</title>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>IRQ SERVICE ROUTINE</entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>SERVICE DEVICE INTERRUPTS</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
Although this routine is not included in the device driver
module branch table and is not called directly by RBFMAN, it is an
key routine in interrupt-driven device drivers. Its function is to:</para>

<para>1. Service device interrupts.</para>

<para>2. When the I/O is complete, the IRQ service routine should send
a wake up signal to the process whose process ID is in V.WAKE</para>

<para>Also clear V.WAKE as a flag to the mainline program that the IRQ
has indeed occurred.</para>

<para>NOTE: When the IRQ service routine finishes servicing an interrupt
it must clear the array and exit with an RTS instruction.</para>
</sect2>

<sect2>
<title>NAME: BOOT (Bootstrap Module)</title>
<informaltable frame="none" rowsep="0" colsep="0">
<tgroup cols="2">
<colspec colwidth="1.4in"/>
<colspec colwidth="3.0in"/>
<tbody>
<row>
	<entry>NAME:</entry>
	<entry>BOOT (Bootstrap Module)</entry>
</row>
<row>
	<entry>INPUT:</entry>
	<entry>None.</entry>
</row>
<row>
	<entry>OUTPUT:</entry>
	<entry><literallayout>(U) = SIZE OF THE BOOT FILE (in bytes)
(X) = ADDRESS OF WHERE THE BOOT FILE WAS LOADED IN MEMORY</literallayout></entry>
</row>
<row>
	<entry>ERROR OUTPUT:</entry>
	<entry><literallayout>(CC) = C bit set.
(B) = Appropriate error code.</literallayout></entry>
</row>
<row>
	<entry>FUNCTION:</entry>
	<entry>LOAD THE BOOT FILE INTO MEMORY FROM MASS-STORAGE</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>NOTE: The BOOT module is <emphasis>not</emphasis> part of the disk driver. It is a
separate module which is normally co-resident with the <quote>OS9P2</quote> module
in the system firmware.</para>

<para>
The bootstrap module contains one subroutine that loads the
bootstrap file and some related information into memory, it uses the
standard executable module format with a module type of <quote>system</quote>
(code $C). The execution offset in the module header contains the
offset to the entry point of this subroutine.</para>

<para>It obtains the starting sector number and size of the
<filename>OS9Boot</filename>
file from the identification sector (LSN 0). OS-9 is called to
allocate a memory area large enough for the boot file, and then it
loads the boot file into this memory area.</para>

<para>1. Read the identification sector (sector zero) from the disk.
BOOT must pick its own buffer area. The identification sector
contains the values for DD.BT (the 24 bit logical sector number of
the bootstrap file), and DD.BSZ (the size of the bootstrap file in
bytes). For a full description of the identification sector.
See <xref linkend="lsn1"/>.</para>

<para>2. After reading the identification sector into the buffer, get
the 24 bit logical sector number of the bootstrap file from DD.BT.</para>

<para>3. Get the size (in bytes) of the bootstrap file from DD.BSZ. The
boot is contained in one logically contiguous block beginning at the
logical sector specified in DD.BT and extending for (DD.BSZ/256+1)
sectors.</para>

<para>4. Use the OS9 <xref linkend="f.srqmem"/> service request to
request the memory area where the boot file will be loaded into.</para>

<para>5. Read the boot file into this memory area.</para>

<para>6. Return the size of the boot file and its location.</para>
</sect2>
</sect1>
</chapter>

